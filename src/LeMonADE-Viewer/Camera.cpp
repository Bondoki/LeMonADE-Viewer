/*--------------------------------------------------------------------------------
 _______________
|   /       \   | L   attice-based  | LeMonADE-Viewer:
|  /   ooo   \  | e   xtensible     | ----------------
| /  o\.|./o  \ | Mon te-Carlo      | An Open Source Visualization Tool for
|/  o\.\|/./o  \| A   lgorithm and  | for BFM-files generated by LeMonADE-software.
|  oo---0---oo  | D   evelopment    | See: https://github.com/LeMonADE-project/LeMonADE
|\  o/./|\.\o  /| E   nvironment    |
| \  o/.|.\o  / | -                 |
|  \   ooo   /  | Viewer            | Copyright (C) 2013-2015 by
|___\_______/___|                   | LeMonADE-Viewer Principal Developers (see AUTHORS)
----------------------------------------------------------------------------------

This file is part of LeMonADE-Viewer.

LeMonADE-Viewer is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE-Viewer is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE-Viewer.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#include <LeMonADE-Viewer/Camera.h>

#include <fstream>
#include <ostream>
#include <iostream>

Camera::Camera() {
  
  //Camera position
  camXPos = 0.0f;
  camYPos = 0.0f;
  camZPos = 0.0f;
 
  //Camera rotation angles
  camPhiRot = 0.0f;		// rotation in x-z-plane
  camThetaRot = 0.0f;		// rotation perpendicular to x-z-plane
  
  //Axis for camera rotation with angle theta
  camThetaRotAxisX = 1.0f;
  camThetaRotAxisZ = 0.0f;
  
  //Linear Camera movement (left, right, up, down, in out)
  camXSpeed = 0.0f;
  camYSpeed = 0.0f;
  camZSpeed = 0.0f;
  
  camPhiRotSpeed= 0.0f;
  camThetaRotSpeed= 0.0f;

  movementSpeedFactor = 1.0f;
  
  //Is a key pressed for linear camera movement?
  holdingForwardI = false;	// key I = zoom in
  holdingBackwardO = false;	// key O = zoom out
  holdingUpW = false;		// key W = move up
  holdingDownS = false;		// key S = move down
  holdingLeftA = false;		// key A = move left
  holdingRightD = false;	// key D = move right
  
  //Is the mouse button pressed for camera rotation?
  holdingMouseButtonLeft = false;
  
  holdingForwardMouse = 0.0f;
  holdingBackwardMouse = 0.0f;
}

Camera::~Camera() {
  
}

/****************************/
//Get camera position

GLfloat Camera::getCamXPos() const {
  return camXPos;
}

GLfloat Camera::getCamYPos() const {
  return camYPos;
}

GLfloat Camera::getCamZPos() const {
  return camZPos;
}

//Get rotation angles
GLfloat Camera::getCamPhiRot() const {
  return camPhiRot;
}

GLfloat Camera::getCamThetaRot() const {
  return camThetaRot;
}

//Get x- and z-component of the rotation axis for rotation angle theta 
GLfloat Camera::getCamThetaRotAxisX() const {
  return camThetaRotAxisX;
}

GLfloat Camera::getCamThetaRotAxisZ() const {
  return camThetaRotAxisZ;
}

//Get linear camera movement
GLfloat Camera::getCamXSpeed() const {
  return camXSpeed;
}

GLfloat Camera::getCamYSpeed() const {
  return camYSpeed;
}

GLfloat Camera::getCamZSpeed() const {
  return camZSpeed;
}

GLfloat Camera::getMovementSpeedFactor() const {
  return movementSpeedFactor;
}

//Get the button-pressed-status for the "linear-movement" buttons
bool Camera::getHoldingForwardI() const {
  return holdingForwardI;
}

bool Camera::getHoldingBackwardO() const {
  return holdingBackwardO;
}

bool Camera::getHoldingUpW() const {
  return holdingUpW;
}

bool Camera::getHoldingDownS() const {
  return holdingDownS;
}

bool Camera::getHoldingLeftA() const {
  return holdingLeftA;
}

bool Camera::getHoldingRightD() const {
  return holdingRightD;
}

//Get the button-pressed-status for the mouse button (used for rotation)
bool Camera::getHoldingMouseButtonLeft() const {
  return holdingMouseButtonLeft;
}

//Get the status for mouse-wheel-zooming
GLfloat Camera::getHoldingForwardMouse() const {
  return holdingForwardMouse;
}

GLfloat Camera::getHoldingBackwardMouse() const {
  return holdingBackwardMouse;
}

/****************************/
//Set camera position
void Camera::setCamXPos(GLfloat camXPosParam) {
  this->camXPos = camXPosParam;
}

void Camera::setCamYPos(GLfloat camYPosParam) {
  this->camYPos = camYPosParam;
}

void Camera::setCamZPos(GLfloat camZPosParam) {
  this->camZPos = camZPosParam;
}


//Set rotation angles
void Camera::setCamPhiRot(GLfloat camPhiRotParam) {
  this->camPhiRot = camPhiRotParam;
}

//Set rotation angles
void Camera::setCamPhiRotSpeed(GLfloat camPhiRotSpeedParam) {
  this->camPhiRotSpeed = camPhiRotSpeedParam;
}

void Camera::setCamThetaRot(GLfloat camThetaRotParam) {
  this->camThetaRot = camThetaRotParam;
}

void Camera::setCamThetaRotSpeed(GLfloat camThetaRotSpeedParam) {
  this->camThetaRotSpeed = camThetaRotSpeedParam;
}

//Set x- and z-component of the rotation axis for rotation angle theta 
void Camera::setCamThetaRotAxisX(GLfloat camThetaRotAxisXParam) {
  this->camThetaRotAxisX = camThetaRotAxisXParam;
}

void Camera::setCamThetaRotAxisZ(GLfloat camThetaRotAxisZParam) {
  this->camThetaRotAxisZ = camThetaRotAxisZParam;
}

void Camera::setCamXSpeed(GLfloat camXSpeedParam) {
  this->camXSpeed = camXSpeedParam;
}

//Get linear camera movement
void Camera::setCamYSpeed(GLfloat camYSpeedParam) {
  this->camYSpeed = camYSpeedParam;
}

void Camera::setCamZSpeed(GLfloat camZSpeedParam) {
  this->camZSpeed = camZSpeedParam;
}

void Camera::setMovementSpeedFactor(GLfloat movementSpeedFactorParam) {
  this->movementSpeedFactor = movementSpeedFactorParam;
}

//Set the button-pressed-status for the "linear-movement" buttons
void Camera::setHoldingForwardI(bool holdingForwardIParam) {
  this->holdingForwardI = holdingForwardIParam;
}

void Camera::setHoldingBackwardO(bool holdingBackwardOParam) {
  this->holdingBackwardO = holdingBackwardOParam;
}

void Camera::setHoldingUpW(bool holdingUpWParam) {
  this->holdingUpW = holdingUpWParam;
}

void Camera::setHoldingDownS(bool holdingDownSParam) {
  this->holdingDownS = holdingDownSParam;
}

void Camera::setHoldingLeftA(bool holdingLeftAParam) {
  this->holdingLeftA = holdingLeftAParam;
}

void Camera::setHoldingRightD(bool holdingRightDParam) {
  this->holdingRightD = holdingRightDParam;
}

//Set the button-pressed-status for the mouse button (used for rotation)
void Camera::setHoldingMouseButtonLeft(bool holdingMouseButtonLeftParam) {
  this->holdingMouseButtonLeft = holdingMouseButtonLeftParam;
}

void Camera::setHoldingForwardMouse (GLfloat holdingForwardMouseParam) {
  this->holdingForwardMouse = holdingForwardMouseParam;
}

void Camera::setHoldingBackwardMouse (GLfloat holdingBackwardMouseParam) {
  this->holdingBackwardMouse = holdingBackwardMouseParam;
}

/****************************/

//Funktion to calculate the radian values of rotation angles
float Camera::toRads(const float theAngleinDegrees) {
  float pi = atan(1)*4;
  return theAngleinDegrees * pi / 180.0f;
}

/****************************/

//Funktion to calculate the linear camera movement
void Camera::calculateCameraMovement() {
  
  float camMovementXComponent = 0.0f;
  float camMovementYComponent = 0.0f;
  float camMovementZComponent = 0.0f;
  
  //If one of the buttons is pressed, the camera gets moved in the appropriate 
  //direction with constant speed. This means, a position difference is calculated 
  //(can be either + or - movementSpeedFactor).
  if (holdingForwardI == true) {
    camMovementZComponent = -movementSpeedFactor;
  }
  
  if (holdingBackwardO == true) {
   camMovementZComponent = movementSpeedFactor;
  }

  if (holdingUpW == true) {
    camMovementYComponent = movementSpeedFactor;
  }

  if (holdingDownS == true) {
    camMovementYComponent = -movementSpeedFactor;
  }
  

  if (holdingLeftA == true) {
    camMovementXComponent = -movementSpeedFactor;
  }
  
  if (holdingRightD == true) {
    camMovementXComponent = movementSpeedFactor;
  }


  //The absolute position difference/speed of the camera 
  camXSpeed = camMovementXComponent;
  camYSpeed = camMovementYComponent;
  camZSpeed = camMovementZComponent;
  
  //Set a maximum for the camera position difference/speed 
  /*if (camXSpeed > movementSpeedFactor) {
    camXSpeed = movementSpeedFactor;
  }
  
  if (camXSpeed < -movementSpeedFactor) {
    camXSpeed = -movementSpeedFactor;
  }
  
  if (camYSpeed > movementSpeedFactor) {
    camYSpeed = movementSpeedFactor;
  }
  
  if (camYSpeed < -movementSpeedFactor) {
    camYSpeed = -movementSpeedFactor;
  }
  
  if (camZSpeed > movementSpeedFactor) {
    camZSpeed = movementSpeedFactor;
  }
  
  if (camZSpeed < -movementSpeedFactor) {
    camZSpeed = -movementSpeedFactor;
  } 
  */
}


//Funktion to calculate the rotation angles and rotation axis for rotation with angle theta,
//when the mouse button is pressed and the mouse is moved
void Camera::handleMouseMove(int mouseX, int mouseY, GLint boxX, GLint boxY, GLint boxZ) {
  GLfloat horizMouseSensitivity = 10.0f;
  GLfloat vertMouseSensitivity = 10.0f;
  
  //movement angle phi in x-z-plane when mouse is moved horizontally
  float phiMovement = (mouseX * 180.0f) / boxX; 
  //movement angle theta perpendicular to x-z-plane when mouse is moved vertically
  float thetaMovement = - (mouseY * 180.0f) / boxY; 
  
  camPhiRot += phiMovement / horizMouseSensitivity;
  camThetaRot += thetaMovement / vertMouseSensitivity;
 
  camPhiRotSpeed = phiMovement / horizMouseSensitivity /5.f;
  camThetaRotSpeed = thetaMovement / vertMouseSensitivity  /5.f;


  float camPhiRads = toRads(camPhiRot);
  float camThetaRads = toRads(camThetaRot);
  
  //Calculation of the rotation axis for angle theta
  //This is needed to ensure that displayed simulation box is always rotated in the same direction when 
  //the mouse is moved e.g. upwards
  camThetaRotAxisX = cos(camPhiRads);
  camThetaRotAxisZ = sin(camPhiRads);
  
  
}

//Funktion to set the new camera position after a linear movement
void Camera::moveCamera() {
  camXPos += camXSpeed; 
  camYPos += camYSpeed;
  camZPos += camZSpeed;
  

  
  camYPos += -holdingForwardMouse;
  camYPos += holdingBackwardMouse;
  
  holdingForwardMouse = 0.0f;
  holdingBackwardMouse = 0.0f;
  
  camPhiRot += camPhiRotSpeed;
  camThetaRot+= camThetaRotSpeed;

  float camPhiRads = toRads(camPhiRot);
  camThetaRotAxisX = cos(camPhiRads);
  camThetaRotAxisZ = sin(camPhiRads);


}
